classdef inputHandler < handle & matlab.mixin.SetGet
% Wrapper for standard inputParser, making it easier to create a syntax
% similar to those used by MATLAB's native graphics commands like plot().
%
% Usage:
%   When enumerating the required and optional variables the order you add
%   them in matters. For example to define an argument sequence similar to
%       your_fn(Xdata,Ydata)
%       your_fn(Parent,__)
%       your_fn(...,Name,Value)
%           with 'XData','YData','Parent', and 'Color' as valid parameters
%   call:
%   > iH = extras.inputHandler;
%   > iH.addOptionalVariable('Parent',gobjects(0),...
%           @(x) ~isnumeric(x)&&isgraphics(x),true); %ignore graphics
%                                                   % specified as numerics
%   > iH.addRequiredVariable('XData',@(x) isnumeric(x),true);
%   > iH.addRequiredVariable('YData',@(x) isnumeric(x),true);
%   > iH.addParameter('Color','r',...
%       @(x) ischar(x)||(isnumeric(x)&&numel(x)==3));
%
% Then when you want to parse inputs just call
%   > iH.parse(YOUR_INPUTS{:});
%
% Results:
%   Similar to MATLAB's inputParser, the parsed results are stored as a
%   struct inside inputHandler.Results
%       Fields of inputHandler.Results correspond with the specified
%       variable and parameter names
%% Copyright 2019 Daniel T. Kovari, Emory University
%   All rights reserved.

    properties (Dependent)
        CaseSensitive %T/F specifying in Name,Value parameter search is case sensitive
        KeepUnmatched %T/F specifying if Name,Value search should allow unmatched parameters
        PartialMatching %T/F if Name,Value search is allows partial matching
        Parameters %list of all parameter names
        VariableNames %list of all variables and parameters
    end
    methods
        function set.CaseSensitive(this,val)
            this.in_parser.CaseSensitive = val;
        end
        function set.KeepUnmatched(this,val)
            this.in_parser.KeepUnmatched = val;
        end
        function set.PartialMatching(this,val)
            this.in_parser.PartialMatching = val;
        end
        
        function val = get.CaseSensitive(this)
            val = this.in_parser.CaseSensitive;
        end
        function val = get.KeepUnmatched(this)
            val = this.in_parser.KeepUnmatched;
        end
        function val = get.PartialMatching(this)
            val = this.in_parser.PartialMatching;
        end
        function val = get.Parameters(this)
            val = this.in_parser.Parameters;
        end
        function val = get.VariableNames(this)
            val = union(this.Parameters,{this.variables.Name});
        end
    end
    
    properties(SetAccess=private)
        Results = struct(); %Results structure
        UsingDefaults = {}; %list of variables and parameters which are using default values
        Unmatched = struct(); %struct generated by inputParser which can be used to forward unmatched variables to another function/parser
        RequiredNotFound = {}; %list of variables which are required but were not found in the previous call to parse()
    end
    
    properties (Access=private)
        variables = struct('Name',{},'DefaultValue',{},'Validator',{},'Required',{},'IncludeAsParameter',{}); %struct listing required and optional variables
        in_parser = inputParser(); %inputParser used for handling parameters
    end
    
    methods
        function addRequiredVariable(this,Name,Validator,IncludeAsParameter)
        % Add Required Variable to the list of variables to search for
        %   The order you add variable matters. If you have added an
        %   optional variable befre a required variable, then the optional
        %   variable's validator will be applied to the input arguments of
        %   parse() before the required variable's validator is checked.
        %
        %   If IncludeAsParameter==false (default) then parse will throw an
        %   error if a value matching the validator cannot be located.
        %
        % Input:
        %   Name: char array specifying variable name.
        %         If Name is not a valid MATLAB variable name a new name is
        %         generated using
        %               Name = matlab.lang.makeValidName(Name)
        %
        %   Validator: function handle (should expect on argument) which
        %   returns true/false if the variable interpreted as Name is valid
        %
        %   IncludeAsParameter (=false): logical scalar specifying if Name
        %   should be seached for among the Name,Value input parameters
            
            if ~exist('Name','var')
                error('Name must be specified');
            end
            if ~exist('Validator','var')
                error('Validator must be specified for RequiredVariable types')
            end
            
            if ~exist('IncludeAsParameter','var')
                IncludeAsParameter = false;
            end
                
            
            assert(ischar('Name'),'Name must be a char array sepcifying valid variable name');
            validName = matlab.lang.makeValidName(Name);
            %check name
            if ~strcmp(validName,Name)
                warning('%s is not a valid variable name. Using %s instead',Name,validName);
            end
            
            assert(isa(Validator,'function_handle'),'Validator for %s must be a function handle',validName);
            
            [lia,lob] = ismember(validName,{this.variables.Name});
            if lia
                warning('%s is already specified as a variable name. Replacing.',validName);
                this.variables(lob) = struct('Name',validName,'DefaultValue',DefaultValue,'Validator',Validator,'Required',true,'IncludeAsParameter',IncludeAsParameter);
            else
                %% add to list
                this.variables(end+1) = struct('Name',validName,'DefaultValue',[],'Validator',Validator,'Required',true,'IncludeAsParameter',IncludeAsParameter);
            end
        end
        function addOptionalVariable(this,Name,DefaultValue,Validator,IncludeAsParameter)
        % Add Optional Variable to the list of variables to search for
        %   The order you add variable matters. If you have added an
        %   optional variable befre a required variable, then the optional
        %   variable's validator will be applied to the input arguments of
        %   parse() before the required variable's validator is checked.
        %   If the optional validator fails, that input  will be checked
        %   against the next variable (optional or required) in the list
        %
        %   If IncludeAsParameter==false (default) then parse will throw an
        %   error if a value matching the validator cannot be located.
        %
        % Input:
        %   Name: char array specifying variable name.
        %         If Name is not a valid MATLAB variable name a new name is
        %         generated using
        %               Name = matlab.lang.makeValidName(Name)
        %   DefaultValue: Default value to use if variable is not specified
        %
        %   Validator: function handle (should expect on argument) which
        %   returns true/false if the variable interpreted as Name is valid
        %
        %   IncludeAsParameter (=false): logical scalar specifying if Name
        %   should be seached for among the Name,Value input parameters
            
            %% Check inputs
            if ~exist('Name','var')
                error('Name must be specified');
            end
            if ~exist('DefaultValue','var')
                error('DefaultValue must be specified for OptionalVariable types')
            end
            if ~exist('Validator','var')
                error('Validator must be specified for OptionalVariable types')
            end
            if ~exist('IncludeAsParameter','var')
                IncludeAsParameter = false;
            end
            try
                IncludeAsParameter = logical(IncludeAsParameter);
            catch
                error('IncludeAsParameter must be scalar and convertable to logical');
            end
            assert(isscalar(IncludeAsParameter),'IncludeAsParameter must be scalar and convertable to logical');
            
                
            %% validate
            assert(ischar('Name'),'Name must be a char array sepcifying valid variable name');
            validName = matlab.lang.makeValidName(Name);
            
            assert(isa(Validator,'function_handle'),'Validator for %s must be a function handle',validName);
            
            [lia,lob] = ismember(validName,{this.variables.Name});
            if lia
                warning('%s is already specified as a variable name. Replacing.',validName);
                this.variables(lob) = struct('Name',validName,'DefaultValue',DefaultValue,'Validator',Validator,'Required',false,'IncludeAsParameter',IncludeAsParameter);
            else
                %% add to list
                this.variables(end+1) = struct('Name',validName,'DefaultValue',DefaultValue,'Validator',Validator,'Required',false,'IncludeAsParameter',IncludeAsParameter);
            end
        end
        function addParameter(this,Name,DefaultValue,Validator)
        % adds the parameter name of an optional name-value pair argument 
        % into the input parser scheme. When the inputs to a function do 
        % not include this optional name-value pair, the input parser 
        % assigns paramName the value defaultVal.
        %
        % Inputs:
        %   Name: char array specifying Parameter name.
        %   DefaultValue: Default value to use if variable is not specified
        %   Validator: function handle (should expect on argument) which
        %   returns true/false if the variable interpreted as Name is valid

            %% Check inputs
            if ~exist('Name','var')
                error('Name must be specified');
            end
            if ~exist('DefaultValue','var')
                error('DefaultValue must be specified for OptionalVariabl types')
            end
            
            if ~exist('Validator','var')
                addParameter(this.in_parser,Name,DefaultValue);
            else
                addParameter(this.in_parser,Name,DefaultValue,Validator);
            end
        end
    end
    
    %% parse
    methods
        function this = parse(this,varargin)
        % Process the specified input arguments
        % Usage:
        %   iH.parse(Arg1,Arg2,'Param1',Val1,'Param2',Val2,...);
        %       or simply forward a cell array (such as varargin)
        %   iH.parse(YOUR_VARS{:});
        
            ReqNotFound = {this.variables(this.variables.Required).Name};
            OptNotFound = {this.variables(~[this.variables.Required]).Name};
            VarRes = struct();
            
            this_parser = copy(this.in_parser);
            
            %% loop over optional and required variables
            for n=1:numel(this.variables)
                if ~isempty(varargin()) %there are variables to process
                    
                    %% Investigate varargin{1}
                    if ~this.variables(n).Required %optional
                        if this.variables(n).Validator(varargin{1}) %passes validator
                            VarRes.(this.variables(n).Name) = varargin{1};
                            varargin(1)= []; %clear from varargin list
                            OptNotFound = setdiff(OptNotFound,this.variables(n).Name);
                        elseif this.variables(n).IncludeAsParameter %include in parameter search
                            addParameter(this_parser,this.variables(n).Name,this.variables(n).DefaultValue,this.variables(n).Validator);
                            OptNotFound = setdiff(OptNotFound,this.variables(n).Name);
                        else %don't add as parameter,just use default
                            VarRes.(this.variables(n).Name) = this.variables(n).DefaultValue;
                        end
                    else %required
                        if this.variables(n).Validator(varargin{1}) %passes validator
                            VarRes.(this.variables(n).Name) = varargin{1};
                            varargin(1)= []; %clear from varargin list
                            ReqNotFound = setdiff(ReqNotFound,this.variables(n).Name);
                        elseif this.variables(n).IncludeAsParameter %include in parameter search
                            addParameter(this_parser,this.variables(n).Name,this.variables(n).DefaultValue,this.variables(n).Validator);
                            ReqNotFound = setdiff(ReqNotFound,this.variables(n).Name);
                        else %don't add as parameter, throw error because we didn't find a required variable
                            warning('Did not find input which passes validator for Required Variable: %s',this.variables(n).Name);
                        end
                    end 
                elseif this.variables(n).Required
                    error('No input arguments remaining and Required Variable %s has not been found',this.variables(n).Name);
                end
            end
           
            %% Check if we missed something
            if ~isempty(varargin) && ~ischar(varargin{1})
                error('Argument(s) were passed which did not match any of the Optional/Required variables.\nMissing Requirements: %s',ReqNotFound);
            end
            
            %% Use Input Parser to check for remaining arguments
            parse(this_parser,varargin{:});

            Parse_Results = this_parser.Results;
            Parse_UsingDefaults = this_parser.UsingDefaults;
            
            %% check for required
            Req = {this.variables(this.variables.Required).Name};
            RNotFound = intersect(Req,Parse_UsingDefaults);
            Parse_UsingDefaults = setdiff(Parse_UsingDefaults,RNotFound);
            Parse_Results = rmfield(Parse_Results,RNotFound);
            this.RequiredNotFound = union(ReqNotFound,RNotFound);
            
            %% Set results, etc.
            this.UsingDefaults = union(OptNotFound,Parse_UsingDefaults);
            
            %merge Results structs
            fn = fieldnames(Parse_Results);
            for n=1:numel(fn)
                if isfield(VarRes,fn{n})
                    error('Results field: %s found in parse output and variable list',fn{n});
                end
                VarRes.(fn{n}) = Parse_Results.(fn{n});
            end
            this.Results = VarRes;
            
            this.Unmatched = this.in_parser.Unmatched;
            
            %% Check to see if Required variables have not been found
            if ~isempty(this.RequiredNotFound)
                error('Did not find required arguments: %s',this.RequiredNotFound);
            end            
        end
    end
            
end